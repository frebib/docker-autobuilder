#!/bin/bash
set -e

join() { local d=$1; shift; echo -n "$1"; shift; printf "%s" "${@/#/$d}"; }
print_msg() { >&2 echo -e "\e[1m${1}\e[0m"; }
looperr() { print_msg "=> Error updating '$1', line $2, exit-code $3"; }
arerror() { print_msg "=> Error: $(basename $0): $*"; }
conterr() { print_msg "=> Error: $1: $2"; }
error()   { print_msg "=> Error: $(basename $0): $*"; }

print_msg "=> Performing update check at $(date +"%a %d %b %Y, %H:%M")"

CONFIG_DIR=$(realpath ${1:-${CONFIG_DIR:-/config}})
RELEASE_DIR=$(realpath ${RELEASE_DIR:-/release})

cd "$CONFIG_DIR"

if ! [ -d "$CONFIG_DIR" ]; then
    error "Configuration directory '$CONFIG_DIR' doesn't exist"
    exit 5
fi
if ! [ -d "$RELEASE_DIR" ]; then
    print_msg "=> Warning: Release directory '$RELEASE_DIR' doesn't exist"
    mkdir -p "$RELEASE_DIR" || {
        arerror "Failed to create release directory '$RELEASE_DIR'"
        exit 6
    }
fi

containers=($(find . -maxdepth 1 -type d -not -name '.*' | sed 's|^\./||g' | tac | xargs))

# Count the containers
COUNT=${#containers[@]}
i=0

if [ $COUNT -gt 0 ]; then
    print_msg "=> Found container configs: $(join ', ' ${containers[@]})"
else
    print_msg "   No container configs found"
    exit 0
fi


trap 'looperr "$CONT" "$LINENO" "$?"; continue' ERR
set +e # Errors now handled by the trap
for CONT in ${containers[@]}; do
    ((i+=1))
    print_msg "\n=> Checking for updates to $CONT ($i/$COUNT)"

    CONT_DIR="$CONFIG_DIR/$CONT"
    cd "$CONT_DIR"

    for script in get-release compare-version; do
        if ! [ -e "$CONT_DIR/$script" ]; then
            conterr "$CONT" "script '$script' not found"
            continue 2
        elif ! [ -x "$CONT_DIR/$script" ]; then
            conterr "$CONT" "file '$script' is not set executable"
            continue 2
        fi
    done

    # Magic stdout/stderr to variables http://stackoverflow.com/a/26827443
    #   ret     is $?
    #   version is stdout
    #   release is stderr
    . <({ release=$({ version=$(./get-release); } 2>&1; ret=$?; { declare -p version; declare -p ret; } >&2); declare -p release; } 2>&1)

    if [ $ret -ne 0 ]; then
        echo "$version" | sed 's|^|   |g' >&2
        conterr "$CONT" "get-release returned $ret"
        continue
    fi

    print_msg "   Latest version is  '$version'"

    RELEASE_FILE="$RELEASE_DIR/$CONT/$version"
    PREV_RELEASE_FILE="$RELEASE_DIR/$CONT/.latest_build"
    # Save release info to file
    mkdir -p "$RELEASE_DIR/$CONT"
    echo "$release" > "$RELEASE_FILE"

    if [ -f "$PREV_RELEASE_FILE" ]; then
        if [ -h "$PREV_RELEASE_FILE" ]; then
            ACTUAL_FILE=$(readlink -m "$PREV_RELEASE_FILE")
            if ! [ -f "$ACTUAL_FILE" ]; then
                arerror "Symbolic link $PREV_RELEASE_FILE points to a file that doesn't exist. "
                DEFAULT_BUILD=true
            else
                PREV_RELEASE_VERSION="$(basename "$ACTUAL_FILE")"
                print_msg "   Previous build was '$PREV_RELEASE_VERSION'"
            fi
        else
            print_msg "   Warning: $PREV_RELEASE_FILE isn't a symbolic link,"
            print_msg "            continuing without previous version argument"
        fi
    else
        print_msg "   Warning: $PREV_RELEASE_FILE doesn't exist"
        DEFAULT_BUILD=true
    fi

    if [ "$DEFAULT_BUILD" = "true" ]; then
        print_msg "   Building image as fallback, some version-comparison details are missing"
        BUILD=true
    else
        ./compare-version "$version" "$RELEASE_FILE" "${PREV_RELEASE_VERSION:-}" "$ACTUAL_FILE" && ret=$? || ret=$?
        case $ret in
            0)   print_msg "   Release version is newer!"; BUILD=true;;
            255) print_msg "   Already most recent version"; continue;;
            *)   conterr "$CONT" "compare-version returned with exit code $ret";;
        esac
    fi

    # To build, or not to build, that is the question
    ["$BUILD" != "true" ] && continue

    print_msg "=> Building image $CONT"

done
